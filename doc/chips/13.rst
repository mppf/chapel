.. _record-copies:

Designing Record Copy Semantics to Support Arrays
=================================================

Status:
  Draft

Authors:
  Michael Ferguson

Abstract
--------

Introduction
------------

This CHIP seeks to solve the problem of array memory management in
Chapel. This is an important problem because any array memory leak limits
the usefulness of the Chapel language. At the same time, since arrays
are frequently used in Chapel programs, overhead of managing their memory
impacts the performance of most Chapel programs. Lastly, this issue cuts
accross language design, compiler implementation, and module code
implementation.

The current implementation uses array reference counting but that is no
longer necessary because of changes in the language (see
http://chapel.cray.com/docs/latest/language/evolution.html#lexical-scoping ).

While there is general agreement that arrays no longer need reference
counting, the current semantics make this changing this strategy
challenging. A simple strategy would be to treat arrays in a similar
manner to strings - each array variable is freed when it goes out of
scope and copy causes the array data to be copied into separate memory.
Problems with this approach include:

 * arrays currently return by reference and some idioms depend on this
   property for performance
 * returning a slice of a local array is an important idiom
   that needs to continue to work

This CHIP describes an approach to implement arrays using records that
overcomes these challenges. These arrays will be freed when they go out of
scope and do not need to include reference counting. In order to make this
approach work, this CHIP proposes adjustments to the currently implemented
behavior of both records and arrays.

Existing Approach
+++++++++++++++++

The existing approach to manage array memory is to implement arrays in
terms of records. These records receive some special treatment within the
compiler. The implementation works with autoCopy, initCopy, and
autoDestroy.

 * autoCopy is called when returning a global array or when passing an array to
   a task function
 * initCopy is called when assigning an array to a user-level variable
 * autoDestroy is called when an array variable goes out of scope

In the current implementation, autoCopy initializes a new array variable
to point to the same array data but increments a reference count for the
array data.  initCopy allocates new array data and initializes it with
the old array and sets the reference count for the new array data to 1.
autoDestroy decrements the reference count for the array data and frees
the array data if it reaches 0.

While autoCopy and initCopy make some sense as a way to implement array
reference counting, the current implementation has some drawbacks:

 * it leaks memory for distributed arrays
 * reference counting is no longer semantically necessary
 * it adds more copies than are strictly necessary
 * program performance depends on whether or not the user gives
   a name to an expression

The example below helps to discuss the last two points. It causes two copy
initializations where other languages might implement the same pattern without
any copies.

.. code-block:: chapel

  proc returnArray() {
    var A:[1..10] int;
    return A;
  }

  proc returnReturnArray() {
    var B = returnArray();     // var B = call() causes initCopy()
    return B;
  }

  var C = returnReturnArray(); // var C = call() causes initCopy()
  writeln(C);

Confusingly, adjusting `returnReturnArray` to consist of just `return
returnArray()` causes the program to generate one fewer initCopy() call.

Function Return Behavior
++++++++++++++++++++++++

In Chapel 1.13, records and arrays have different behavior when returned from a
function. In particular, records return by value - but arrays return by
reference. The following example shows the issue.

.. code-block:: chapel

  record R {
    var element:int;
  }

  var globalArray:[1..1] int;
  var globalRecord:R;

  proc returnArray() {
    return globalArray;
  }
  proc returnRecord() {
    return globalRecord;
  }

  writeln("globalArray is ", globalArray);
  writeln("setting returnArray()[1] to 2");
  returnArray()[1] = 2;
  writeln("globalArray is now ", globalArray);

  writeln(globalArray);

  writeln("globalRecord is ", globalRecord);
  writeln("setting returnRecord().element to 3");
  returnRecord().element = 2;
  writeln("globalRecord is now ", globalRecord);

The above program has output

::

  globalArray is 0
  setting returnArray()[1] to 2
  globalArray is now 2
  2
  globalRecord is (element = 0)
  setting returnRecord().element to 3
  globalRecord is now (element = 0)

This behaviour might be in conflict with the current language
specification. In spec version 0.981, section 13.7 says "By default, or
if the return-intent is const, the function returns a value that cannot
be used as an lvalue". From that section, we would expect a compilation
error for this example - for both the array and record cases.  However,
section 20.2 says "Chapel semantics are defined so that the compiler will
never need to insert temporary arrays of the same size as a user array
variable." This implies that returnArray() cannot make a copy of the
globalArray - since such a copy would need to be in a temporary since
there is no user variable in which to place that copy.

In any case, the output of this program is instructive in showing how the
current implementation behaves. We can see from the output that modifying the
array returned from `returnArray` caused a modification to `globalArray` - in
other words, the array returned by reference. In contrast, modifying the value
returned by `returnRecord` did not result in a modification to `globalRecord`.
The record returned by value. 

Note though that in Chapel, both arrays and records are `value types` in that
when you initialize one variable with another, the data is copied. E.g.

.. code-block:: chapel

  var A:[1..1] int;
  var B = A;        // initializes B to a copy of A
  B[1] = 1;
  writeln(A[1]);

outputs `0` because `B` is initialized to a copy of `A`. Compare with a class
type - which is not a value type. There, a similar program would output 1.


Strawman Proposal
+++++++++++++++++

A strawman proposal helps to identify some of the key issues with array
copy initialization. Consider a strawman strategy for implementing arrays
in which they are function similarly to strings:

 * arrays return by value (unless the const ref or ref return intent is
   specified) since that is the behavior for user records
 * autoDestroy frees the array data, so that array data is freed whenever
   that array goes out of scope 
 * initCopy copies of the array data, so that each different variable refers
   to separate memory and can be independently freed.

Such an approach would run into these several challenges. Three examples
demonstrate the issues.

.. _record-copies-strawman-consume-return:

Passing a Call Result into a Function
*************************************

.. code-block:: chapel

  proc returnArray() {
    var A:[1..10] int;
    return A;
  }

  proc consumeArray(A) {
    writeln(A[1]);
  }

  consumeArray(returnArray());

This example is simple enough that it should probably continue to work.
However, since the blank argument intent for an array indicates `ref` argument
intent, if `returnArray` returns `const`, it would be a compiler error since
something that is not an lvalue cannot be passed as a `ref` argument.

.. _record-copies-strawman-xform:

Array Transformation Idiom
**************************

.. code-block:: chapel

  proc xform(arg) {
    arg[1] += 1;
    return arg;
  }

  config const n = 100000;
  var A:[1..n] int;
  var B = xform(xform(xform(A)));

This example shows a potential performance problem for one idiom for
transforming an array in a function call. If arrays return by value, each xform
call would create a new copy of the array. At the same time, the current
behavior adds only one copy of the array data when initializing B.

.. _record-copies-strawman-return-slice:

Returning a Slice of a Local Array
**********************************

.. code-block:: chapel

  proc f() {
    var A:[1..4] int;
    return A[2..3];
  }

  var A_slice = f();
  writeln(A_slice);

This example program is currently valid and it is desireable that it continue
to function. However, under the strawman proposal, the slice construction
A[2..3] would result in a record that points to the same array data as `A`.
This array data will be freed at the end of `f` and subsequent use of the value
returned - including to initialize `A_slice` - will be a access invalid memory
and potentially cause program failure.


Description
-----------

Summary of Approach
+++++++++++++++++++

This CHIP seeks to show how arrays can be implemented in terms of records.  It
does this in three steps. First, it discusses the concepts of `copy
initialization` and `move initialization`. Then, it proposes rules for both
arrays and records that indicate when `copy initialization` and `move
initialization` occur. Finally, it describes how these rules support an
implementation of arrays in terms of records.

The separate document :ref:`record-copies-examples` discusses how the rules
described in this document enable other use cases for records.  The documents
:ref:`record-copies-out-inout` and :ref:`record-copies-expiring` discuss
improvements to the rules described in this proposal.

TODO: Additionaly, the separate document ... discusses how run-time types
interact with this design.

.. commented out

  This document is proposing
  The What is this design trying to achieve?

  The design should provide users with idioms that they can rely on which
  are guaranteed not to create a copy. Lastly, if records are sufficient to
  create Chapel arrays, that is evidence that they are well designed.

  * Array semantics are connected to record semantics
    - purely from a language design viewpoint, arrays and user records
      are both ways to store a collection of values
    - it is a language design goal that a Chapel user should be able
      to create a type similar to the Chapel array. The record type
      needs to be capable enough to enable this use case. The record
      type is really the only type that enables automatic scope-based
      memory management.
    - Arrays can be contained in records and records can be contained in
      arrays.

  Careful optimization of copies in the compiler can apply to both arrays
  and to records.

  It is the belief of the author that the language would be better if arrays and
  records both returned in the same way. The arguments for this are:

   * It enables a conceptual model where a 1-length array has similar
     behavior to a record storing 1 field.
   * It enables more implementation options for arrays. In particular,
     it is clear that small arrays could be implemented with stack
     variables.
   * It enables us to describe study and optimize only one set of copy semantics
     that applies to both arrays and records.
   * It generates clear behavior for records that contain arrays
     and arrays that contain records.
   * It is surprising that introducing a temporary variable to capture
     a function result changes the semantics when the function returns an
     array. (In particular it causes a copy to be added when it did not
     previously).

  Additionally, such unification can simplify the compiler implementation by
  removing special case code for arrays.

  Describe when copy/move occur in words

  Removing Array Reference Counting
  +++++++++++++++++++++++++++++++++
   
  The design described in this document was developed in an attempt to adjust
  record and array semantics so that it would be possible to:

   1) remove array reference counting
   2) continue to implement arrays in terms of records
   3) remove unnecessary copies
   4) allow users to implement custom types with similar behavior to arrays

  An implementation of arrays in terms of records without reference counting
  would consist of an `_array` record which contains a pointer to a class storing
  the array data. Since reference counting is not used, the general strategy is
  for these `_array` records to delete the array data when the record goes out of
  scope.

  Such a design presents a problem for simple examples using array slicing. For
  example, this program

  .. code-block:: chapel

    proc retSlice() {
      var A:[1..10] int;
      return A[2..8];
    }

  would, if care is not taken, destroy the memory used by the slide at the end of
  the function body. One trivial solution would be to always copy an array expression upon return, but that is clearly not optimal.

  Summary of Goals
  ++++++++++++++++

  Summarizing, the goals of this effort are to:

   * develop more optimal array and record copy semantics
   * enable arrays to be implemented in terms
     of records and without reference counting 
   * fully describe the record copy semantics
   
Preliminaries
+++++++++++++

Record Initialization and Destruction
*************************************

Record initialization and destruction are described in CHIP 10.  For the
purposes of this document, it suffices to know that records are destroyed
when they go out of scope and at that time a `deinit` method is called.
A typical `deinit` method would free memory used by a pointer field.

Copy and move concepts
**********************

This proposal uses the terminology `copy` and `move`. These terms
describe how a Chapel program initializes a record variable based upon an
existing record variable. Both `copy` and `move` create a new variable
from an initial variable.

After the `copy` initialization, both the new variable and the initial
variable exist separately. Generally speaking, they can both be modified.
However, they must not refer to the same fields. That is, changing a
field in the new record variable should not change the corresponding
field in the initial record variable.

A `move` is when a record variable changes storage location. It is
similar to a `copy` initialization but it represents a transfer rather than
duplication. In particular, the initial record is no longer available
after the `move`.  A `move` can be thought of as an optimized form a
`copy` followed by destruction of the initial record.  After a `move`,
there is only one record variable - where after a `copy` there are two.

Record authors can adjust copy and move
***************************************

Record authors can specify code to run on a `copy`.  For example, a record that
contains a pointer to a class instance can operate as though the data in the
class instance were stored directly in the record by copying the class instance
in each record `copy` initialization. If a customizeable `copy` were not
available, the record author would be forced to support the case where two
record variables point to the same class instance - or to require that users of
that record include explicity `clone` method calls (for example).

Different languages make a different choice here. C++ and D allow record
authors to implement some part of a `copy`, but Rust and Swift do not.

Record authors can also customize a `move`. In particular, it allows
record authors to better control aliasing for pointer fields. This
feature is important for handling the issue discussed in the strawman
proposal :ref:`record-copies-strawman-return-slice`.


.. _record-copies-postblit-tbd:

Strategy for Customizing `copy` and `move` TBD
**********************************************

Note that at the time of this writing, specific syntax for how a record
can customize `copy` and `move` is still under discussion. The exact
choice does not matter for the question of *when* the compiler adds
`copy` or `move` initialization. However, concrete examples in this
document will use `postblit` and `postmove` as the methods that respond
to `copy` and `move` respectively. With a `postblit` strategy, these
methods are called after a shallow copy is made, e.g. a copy
initialization might consist of:

.. code-block:: chapel

  memcpy(dst, src)
  dst.postblit();

Similarly, a move initialization might consist of

.. code-block:: chapel

  memcpy(dst, src)
  dst.postmove();

The main alternative is to use `proc init` for copy and move
initialization.  In that case, a copy initialization might consist of:

.. code-block:: chapel

  dst.init(src);

How `move` initialization would be customized under the alternative is
also TBD.

Copy and move initialization
****************************

Record copy semantics in Chapel are a combination of two factors.

 1) The compiler adds `copy` or `move` initialization
 2) The record author implements certain methods
    to specify how the record should react to `copy` or `move`.

.. commented out

  Note that when a type has a run-time component, move and copy
  initialization needs to provide the run-time type to the postblit or
  postmove function implemented by the record author. This topic is
  discussed further in :ref:`record-copies-arrays`.

Copy initialization
^^^^^^^^^^^^^^^^^^^

The document :ref:`initialization` provides a canonical example of
when `copy initialization` occurs:

.. code-block:: chapel

  var x:R = ...;
  var y:R = x;    // copy initialization occurs here
  ... uses of both x and y ...;

The `postblit` method
^^^^^^^^^^^^^^^^^^^^^

Note that this section discusses one possible approach and has
not been finalized. See :ref:`record-copies-postblit-tbd`.

A record specifies how it reacts to a copy by providing a `postblit`
method. At the time that the `postblit` method is called, the `this`
variable is already initialized to a shallow copy. The `postblit` method
is responsible for performing a fixup.

.. code-block:: chapel

  class C {
    var a:int;
  }
  record R {
    var ptr:C;
  }
  proc R.postblit() {
    // Fix up for copy
    // e.g. copy a buffer that should not be shared between instances
    this.ptr = new C(a=this.ptr.a);
  }

If no `postblit` method is provided for a record, the compiler provides
one. The compiler-provided `postblit` method calls the `postblit` method
on each record field in turn.

Move initialization
^^^^^^^^^^^^^^^^^^^

Here is an example of when the compiler uses `move` initialization under
this proposal:

.. code-block:: chapel

  record R { ... }
  proc makeR() {
    return new R(...);
  }
  var x = makeR();    // move initialization occurs here


The `postmove` method
^^^^^^^^^^^^^^^^^^^^^

Note that this section discusses one possible approach and has not been
finalized. See :ref:`record-copies-postblit-tbd`.

A record can use a `postmove` method to react to a `move` initialization.  As
with `postblit`, the `this` variable is already initialized with a
shallow copy at the time that the `postmove` method is called. However,
in contrast to the `postblit` method, the initial record variable is destroyed
by the `move` initialization.

If no `postmove` method is provided for a record, the compiler provides
one. The compiler-provided `postmove` method calls the `postmove` method
on each record field in turn.


Rules for when copy or move initialization occur
++++++++++++++++++++++++++++++++++++++++++++++++

The following sections of this document describe situations in which a `copy`
or a `move` is added by the compiler to implement some kind of initialization.
Now, it might seem that the compiler could choose a variety of strategies to
implement one of these initializations. In particular, copy initialization
could be default-initialization followed by assignment. Likewise, move
initialization could be copy initialization followed by destruction of the
source variable.

This proposal takes the position that the language needs to provide a minimum
level of optimization and also provide some reproducability in this area.
Therefore, the semantics described below should be interpreted to be the
behavior the Chapel compiler provides in a baseline configuration (e.g. with
`--baseline`).

It may or may not be worthwhile to allow the compiler to further optimize
these cases, by replacing some `copy` initializations with `move`
initialization. On the one hand, there is an advantage to making programs
always behave the same in this regard. On the other, allowing some
flexibility here can allow programs to perform better and still operate
as expected.

This is a complicated issue because it impacts how Chapel users can
understand Chapel programs. If further optimization is allowed, it either
needs to be documented in detail in the language specification and always
applied - or, the language specification needs to be somewhat vague about
when `copy` or `move` is used.

We discuss how to present these record semantics to users in
:ref:`record-copies-user-view`. We discuss one optimization that could be
applied in :ref:`record-copies-expiring`. 


.. _copy-move-table:

When one record variable is initialized from another, the compiler must choose
whether to perform `copy initialization` or `move initialization`.

The following table shows in which situations a copy or move initialization is
added. Each row in this table corresponds to a particular use of an expression
`<expr>`. Each column indicates the kind the expression `<expr>`. Blank spaces
indicate that no copy or move initialization is necessary.

========================  ==========  =========  =========  ============  ============
operation                 value call  local var  outer var  ref argument  ref/ref call
========================  ==========  =========  =========  ============  ============
variable initialization   move        copy       copy       copy          copy     
field initialization      move        copy       copy       copy          copy     
call as `in` argument     move        copy       copy       copy          copy
value return              move        move       copy (1)   copy (1)      copy
ref return                error       error            
call as `ref` argument                                
========================  ==========  =========  =========  ============  ============

(1) copy on value return can be skipped according to
:ref:`automatic-ref-return`.

Here is more detail on each operation:


variable initialization
  a variable initialization statement as in

  .. code-block:: chapel

    var a=<expr>;

field initialization
  a field initialization statement from Phase 1 of an initializer, as in

  .. code-block:: chapel

    record MyRecord {
      var field:R;

      proc init(...) {
        field = <expr>;
        super.init();
      }
    }


call as `in` argument
  a function call where `<expr>` corresponds to a formal with `in`
  intent, as in

  .. code-block:: chapel

    proc f(in arg) { ... }
    f(<expr>)

value return
  a return statement in a function that returns `by value` - that is,
  does not have `ref` or `const ref` return intent.

  .. code-block:: chapel

    proc f() {
      return <expr>;
    }

ref return
  a return statement in a function that returns `by ref` - that is, with
  `ref` or `const ref` return intent.

  .. code-block:: chapel

    proc g() ref {
      return <expr>;
    }

call as `ref` argument
  a function call where `<expr>` corresponds to a formal with `ref`
  or `const ref` intent (or in cases where blank intent is `ref` or
  `const ref`), as in

  .. code-block:: chapel

    proc f(ref arg) { ... }
    f(<expr>)


Here is more detail on each expression type. The examples below include
some supporting code and then have the form of `... <expr> ...`.

value call
  a call to a function that returns `by value` - that is, does not
  have `ref` or `const ref` return intent.
 
  .. code-block:: chapel

    proc f() { ... }

    ... f() ...;

local var
  a use of a variable local to a function
 
  .. code-block:: chapel

    proc f() {
      var x = ...;
      ... x ...;
    }

outer var
  a use of a variable not local to a function, including a global
  variable or a variable declared in an outer function.
 
  .. code-block:: chapel

    var global:R = ...;
    proc f() {
      ... global ...;
    }

ref argument
  a use of a formal argument that has the `ref` or `const ref` intent
  (or a blank intent that is `ref` or `const ref`).
 
  .. code-block:: chapel

    proc f(const ref arg) {
      ... arg ...;
    }

ref/ref call
  a use of a ref variable or a call returning with `ref` or `const ref`
  return intent.
 
  .. code-block:: chapel

    ref x = ...;
    ... x ...;

  .. code-block:: chapel

    proc g() ref { ... }
    ... g() ...;



.. _ref-return:

`ref` Return Intent
+++++++++++++++++++

The `ref` or `const ref` return intent indicates that unlike a normal
return, the returned value does not transfer the responsibility for
freeing something to the caller.  In other words, returning something by
`ref` does not change when that variable is destroyed.

Return statements inside a function with `ref` or `const ref` return
intent have the following behavior:

 * The `return` statement in a `ref` or `const ref` return intent
   function does not cause a `move` or `copy` initialization to be added. The
   `retVar` is just set to a created reference.
 * unlike non - `ref` returns, coercions and promotions are disabled for
   a ref return intent function. The type of the returned expression must
   match exactly. (This constraint is already described in the language
   specification);
 * it is a program error to return a reference to a value with a type 
   that is different from a function's declared return type.
   This should be flagged as a compile error or an execution-time error.
 * Returning a local variable or temporary in a function with `ref`
   return intent does not prevent that variable or temporary from being
   destroyed and so should be a compile error if possible. In other
   words, it is a program error to return a ref to any variable that is
   allocated on the stack. It is a program error in a ref-return function
   to:

   * directly return a local variable declared by the user.  This can be
     detected with a compiler error.
   * directly return a ref to a call to a function that does not have
     `ref` or `const ref` return intent because that returned value will
     be stored in a function-local temporary. This can be detected with a
     compile error.
   * return a reference to any value that will be destroyed once the
     function exits. It would be difficult for compiler analysis to find
     all such cases.

   
.. _automatic-ref-return:

Automatic `ref` Return Intent
+++++++++++++++++++++++++++++

The table above showed `copy/move` for two value return cases:

 * returning an outer variable
 * returning a ref argument

In these cases, it would be legal to use a `copy` initialization. However, in
some situations, the `copy` is unnecessary and oculd be removed by adding
the `ref` or `const ref` return intent to the function.

For example, consider this program:

.. code-block:: chapel

  record R { ... }
  var global:R = ...;

  proc f() {
    return global;
  }

  writeln(f());

This program causes the record `global` to be copied in the process of
being output, since it is copied during the process of returning from
`f`.  This copy is unnecessary in this example and could be optimized
away. A user might explicitly remove the copies by adding the `const ref`
return intent to `f`.

A further example is this program:

.. code-block:: chapel

  record R { ... }

  proc xform(const ref arg) {
    arg[1] += 1;
    return arg;
  }

  var x:R = ...;
  var y = xform(xform(xform(x)));

Note that if `arg` had the `in` intent, the rules above would optimize
away the copies. However, when `arg` has the `const ref` intent, the
copies can be removed by adding the `const ref` return intent to `xform`.

Both of these programs will not have unnecessary copies because of the
rule described in this section.

The `ref` or `const ref` return intent is added automatically for
functions that always:

  * return a formal argument, where the formal had `ref` or `const ref`
    intent, or
  * return a outer scope variable

The new return intent should match the default argument intent. For user
records, that is `const ref`, but for arrays, it would be `ref`.

Note that it is important to restrict this rule to ref arguments and
outer variables.  It would not in general be valid for this rule to apply
to all functions that always return a ref expression. For example, in the
following:

.. code-block:: chapel

  record R { var x:int; }
  proc f() {
    var a = new R(12);
    ref refA = a; 
    return refA; 
  }

  writeln(f());

the value returned in `f` is always a reference, but it would make the
program erroneous to add the `const ref` return intent to it.

.. commented out 

  Note that for a record, it it is already illegal to assign to the result
  of call not marked with `const ref` return intent. For example

  .. code-block:: chapel

    record R { var x:int; }
    var global = new R(12);

    proc f() {
      return global;
    }

    f() = new R(1);

  results in the error "illegal lvalue in assignment". The transforamtion
  changes this code to:

  .. code-block:: chapel

    record R { var x:int; }
    var global = new R(12);

    proc f() const ref {
      return global;
    }

    f() = new R(1);

  in which the assignment to the result of `f()` is still an error.


.. commented out

  Things to watch out for:

   * returning a reference to a local variable
     (wouldn't want to change a correct program into an incorrect one)
     For example,

     .. code-block:: chapel

        proc f() {
          var x = 12;
          ref y = x; 
          return y; 
        }

        writeln(f());

     This example does not meet the criteria for the transformation above,
     since it returns neither an *outer scope variable* nor a
     *particular ref argument*. This transformation should probably not
     apply to functions returning arbitrary function calls that
     return a `ref`.

     Alternatives include:

       * functions that always return a ref (including the result of a call
         or a ref variable) could be candidates for this transformation. In
         that case, we would probably want to detect common cases of
         returning a ref to a variable that will go out of scope and make
         them into compilation errors. Note though that without language
         changes it is probably not reasonable to expect the compiler to
         detect all such cases.

   * functions returning a reference to a variable
     with unknown lifetime (local? global?). It would be a problem
     if the returned reference has a longer lifetime than
     the variable it refers to.

  Revisiting our earlier examples,

  .. code-block:: chapel

    var A:[1..3] int;

    proc f() {
      return A;
    }

    writeln(f());

  applying the transformation above would change it into the following:

  .. code-block:: chapel

    var A:[1..3] int;

    proc f() ref {
      return A;
    }

    writeln(f());

  Note that a copy of A would still be made in a case such as

  .. code-block:: chapel

    var B = f();

  since f() is a reference and is treated as another variable.

  This example is similarly improved by the transformation:

  .. code-block:: chapel

    proc xform(arg) {
      arg[1] += 1;
      return arg;
    }

    var A:[1..4] int;
    var B = xform(xform(xform(A)));

  Since the array argument to xform is passed by reference and always
  returned, xform can return by reference:

  .. code-block:: chapel

    proc xform(arg) ref {
      arg[1] += 1;
      return arg;
    }

    var A:[1..4] int;
    var B = xform(xform(xform(A)));

  In that case, A is modified by each xform call, instead of sometimes being a
  temporary being modified. This difference is observable if A is not dead after
  its use as an argument.

  This transformation makes the blank return intent not always `by value`.
  In some cases it would be the same as the `ref` or `const ref` return
  intent. We might consider enabling the `out` keyword to be used as an
  explicit return intent as an alternative to `ref`.  If we did so,
  functions with an `out` return intent would not be eligible for this
  transformation. Additionally, we would probably want to also adopt the
  optional extension :ref:`optimizing-out` for language consistency
  reasons.

  Alternatives:

   * create a performance warning. When a function always returns a global
     or an argument, warn that a copy can be removed if the function
     is declared with the `ref` return intent.


TODO
----

* describe `inout` and `out` argument intents
* show how array will be implemented with these rules

.. commented out


  `inout` and `out` argument intents
  ++++++++++++++++++++++++++++++++++

  TODO: describe the semantics of `inout` and `out` argument intents
  (probably drawing from :ref:`record-copies-out-inout` but with less
  implementation detail)

  .. _record-copies-postmove-example:

  Example that uses `postmove`
  ++++++++++++++++++++++++++++

  The following example is a simplified demonstration of a problem that
  comes up when implementing array slicing (see
  :ref:`record-copying-array-slices`).

  The below code declares a record `R` containing a pointer to a class
  instance. The class instance is generally copied when a variable of type
  `R` is copied, but suppose that the record author also needs to support
  explicitly creating a new `R` that has a pointer aliases another `R`'s
  pointer. This can cause a problem if the other record an aliased record
  is destroyed.

  .. code-block:: chapel

    class C {
      var a:int;
    }
    record R {
      var ptr:C;
      var isalias:bool; // does ptr alias another record?
                        // ptr will be deleted if isalias==false.
      proc deinit() {
        // when deleting an R, delete the class instance if it's
        // not an alias.
        if !isalias then delete ptr;
      }
      proc postblit() {
        // when copying an R, also copy the connected class instance.
        this.ptr = new C(a=this.ptr.a);
        this.isalias = false;
      }
    }
    // Explicitly create a new R containing a ptr field that aliases r.ptr.
    proc makeAlias(const ref r:R) {
      return new R(ptr=r.ptr, isalias=true);
    }

    proc test() {
      var r = new R(ptr = new C(1));
      var alias = makeAlias(r);
      return alias; // returning alias with ptr==r.ptr
                    // but r.ptr is deleted in r's destructor
    }
    var r = test();
    // now does r.ptr refer to freed memory?

  The record author could prevent `r` from referring to freed memory in
  this case by providing the following `postmove` method:

  .. code-block:: chapel

    proc R.postmove() {
      if (this.isalias) {
        this.postblit(); // make a new ptr as a copy of old ptr
      }
    }

  With this method, in the process of returning `r` from `test`, the
  `postmove` method will be called on `r`. Since it creates a new copy of
  the `ptr` object, the original `alias.ptr` can safely be destroyed at the
  end of the `test` function.


  Open Issues / TODO
  ++++++++++++++++++

  See :ref:`record-copies-postblit-tbd`.

